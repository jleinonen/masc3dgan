"""
Library and IO utils to read and manipulate
the reconstructed data (from 3D-GAN) 

The 3D-GAN data are NetCDF obtained with the method 
(see under ./examples how to generate them)

jgr 2021

The main object here is called  gan3d, the content of which is
either read from the two NetCDF files generated by 3D-GAN (see below)
or computed here.

This object is mostly suitable for small chunks of data.

"""

import netCDF4 
import numpy as np
import datetime

from scipy import ndimage
from scipy.spatial import ConvexHull

from aggregation import mcs # NOTE this requires https://github.com/jleinonen/aggregation

from utils_aux import polyToParams3D, ls_ellipsoid, weights_on_mass
import matplotlib.pyplot as plt


class gan3d:
    def __init__(self,ganfile='/data/MASC_3D_print/masc_3D_print_grids.nc',
        mascfile='/data/MASC_3D_print/masc_3D_print_triplets.nc',geom_estimation='Weight'):
        
        self.ganfile=ganfile
        self.mascfile=mascfile
        self.geom_estimation=geom_estimation

        self.mass_3d, self.grid_size = self.read_gan_nc() #GAN 3D properties
        self.proj_size, self.time, self.particle_id, self.masc_images = self.read_masc_nc() #MASC captures porperties
        
        # mass, gyration
        self.mass_1d, self.r_g = self.mass_gyration()
        # Volume, Area (CH), Dmax and Axis Ratio
        self.V_ch, self.A_ch, self.D_max, self.R_a = self.geometry(self.geom_estimation)
        # Flake ID (only relevant for the 3D printed testset)
        self.flake_id = masc_id_to_flake_id(self.particle_id,time=self.time)
            
    def read_gan_nc(self):
        # Read NC file (GAN)
        ncobj = netCDF4.Dataset(self.ganfile)
        ncvars = ncobj.variables

        # Put variables in dictionary
        #mass_3d = _ncvar_to_dict(ncvars['mass_3d'])
        mass_3d_gan =  np.asarray(ncvars['mass_3d'])    # kg 
        grid_size_gan  = np.asarray(ncvars['grid_size']) # m

        # Close NC file (GAN)
        ncobj.close()

        return mass_3d_gan, grid_size_gan

    def read_masc_nc(self):
        #  Read NC file (MASC)
        ncobj = netCDF4.Dataset(self.mascfile)
        ncvars = ncobj.variables

        # Return variables
        return np.asarray(ncvars['proj_size']), np.asarray(ncvars['time']), np.asarray(ncvars['particle_id']), np.asarray(ncvars['images'])    

    def mass_gyration(self,N_flakes=None):

        if N_flakes is None:
            N_flakes=self.mass_3d.shape[0]
            print(self.mass_3d.shape)

        mass = np.zeros(N_flakes)   # kg
        r_g = np.zeros(N_flakes)    # m (gyration)
        
        for i in range(N_flakes):
            data = self.mass_3d[i,:,:,:].copy() #kg

            pix_size = self.grid_size[i]/data.shape[0] # m 
            nozero=np.nonzero(data)
            mass_total=data[nozero] # Only positvie mass kept from the matrix [kg]

            data_new = np.transpose(np.asarray(nozero)) # Now is N, 3 array instead of X, Y, Z       
            mass[i] = np.sum(mass_total) #kg

            # Other 1D parameters
            c_m = ndimage.center_of_mass(data) #mass center
            r_g[i] = np.sqrt((((data_new-c_m)**2).sum(1)*mass_total/np.sum(mass_total)).sum())*pix_size #radius of gyration [m]

        return mass, r_g

    def geometry(self,method,N_flakes=None):

        if N_flakes is None:
            N_flakes=self.mass_3d.shape[0]

        D_max = np.zeros(N_flakes)    # kg
        V_ch  = np.zeros(N_flakes)    # m**3 Volume of Convex-Hull
        A_ch  = np.zeros(N_flakes)    # m**2
        R_a   = np.zeros(N_flakes)    # [-]
        
        for i in range(N_flakes):
            data = self.mass_3d[i,:,:,:].copy() #kg
            pix_size = self.grid_size[i]/data.shape[0] # m
            nozero=np.nonzero(data)

            if method == 'Weight':
                th = weights_on_mass(data)['th']
                nozero = np.where((data-th) > 0)

            data_new = np.transpose(np.asarray(nozero)) # Now is N, 3 array instead of X, Y, Z       
            D_max[i]=(2*mcs.minimum_covering_sphere(data_new)[1])*pix_size #Dmax [m]

            c_h = ConvexHull(data_new*pix_size) # Convex hull
            A_ch[i]=c_h.area               #area of c_h [m**2]
            V_ch[i]=c_h.volume             #volume of c_h [m**3]

            # fit ellipsoid on convex hull
            lH       = len(c_h.vertices)
            hull     = np.zeros((lH,3))
            for j in range(len(c_h.vertices)):
                hull[j] = pix_size*data_new[c_h.vertices[j]]
            hull     = np.transpose(hull)         
                
            eansa            = ls_ellipsoid(hull[0],hull[1],hull[2]) #get ellipsoid polynomial coefficients
            center,axes,inve = polyToParams3D(eansa,False)           #get ellipsoid 3D parameters

            R_a[i] = axes.min()/axes.max()

        return V_ch, A_ch, D_max, R_a

def masc_id_to_flake_id(id,time=None):
    """
    Links the numerical incremental MASC flake ID with the original
    string defining the 3D printed snowflake.

    Input:

    id: array or scalar with the INT ids as given by the MASC
    time (optional): unix time in seconds
    """

    id_3d_agg= []    

    for ii, i in enumerate(id):
        if time is not None:
            yyyymmdd=datetime.datetime.utcfromtimestamp(time[ii]).strftime('%Y-%m-%d')
        id_3d_agg.append(id_to_strings(i,yyyymmdd=yyyymmdd))

    return np.asarray(id_3d_agg)

# Dictionary to extract MASC data type
def id_to_strings(argument,yyyymmdd=None): 
    """
    Integer ID to Aggregate string (valid only for 3d prints used in validation of the paper)

    yyyymmdd: string of the type yyyy-mm-dd

    """
    if yyyymmdd == '2020-08-31':
        if argument in [97, 98, 99, 100, 101, 102, 105, 106, 107, 108]:
            return "2mKsiBVO"               
        elif argument in [73, 76, 77, 78, 79, 80, 81, 82, 83, 84]:
            return "aHWy6CAj"
        elif argument in [20, 21, 22, 23, 24, 25, 26, 27, 28, 29]:
            return "b8m4vS3w"
        elif argument in [30, 31, 32, 33, 34, 37, 38, 41, 42]:
            return "c7fUKC7t"
        elif argument in [44, 46, 47, 48, 49, 50, 51, 52, 53]:
            return "IebFGn9p"
        elif argument in [109, 113, 114, 115]:
            return "LOfmd0dX"
        elif argument in [56, 57, 58, 59, 62, 63, 64, 65, 66, 67]:
            return "M9KDMChv"
        elif argument in [71]:
            return "NnWZXfMH"
        elif argument in [85, 88, 89, 90, 91, 92, 93, 94, 95, 96]:
            return "NsMMoLWW"
        else:
            print("Argument not associable to a valid flake: "+str(argument))
            return None
    elif yyyymmdd == '2021-04-20':
        if argument in [16, 17 ,20 ,21 ,22, 23, 24, 27, 28, 29]:
            return "2mKsiBVO"               
        elif argument in [30,31,32,33,34,35,36,37,38,39]:
            return "aHWy6CAj"
        elif argument in [40,41,42,43,44,45,46,47,48,49]:
            return "b8m4vS3w"
        elif argument in [50,51,52,53,54,55,56,57,58,59]:
            return "c7fUKC7t"
        elif argument in [60,61,62,63,64,65,66,67,68,71]:
            return "IebFGn9p"
        elif argument in [72,73,74,75,76,77,78,79,80,81]:
            return "M9KDMChv"
        elif argument in [82,83,84,85,86,87,88,89,90,91]:
            return "NsMMoLWW"
        elif argument in [92, 93,94,95,96,99,100]:
            return "ctqyofwb"
        elif argument in [101,102,103,104,105,106,107,108,109,110,111,
        114,115,116,117,118,119,120,121,124]:
            return "gmlwcerc"
        elif argument in [125, 126, 127, 129, 132, 133, 134, 135, 136, 137, 139,
        140,141,142,143,144,145, 146,149,150]:
            return "llchasht"
        elif argument in [151, 152, 153, 154, 155, 156, 159, 160, 161, 162, 163,
        164, 165, 166, 167, 168, 169, 170, 171, 172]:
            return "nlwolkyv"
        elif argument in [173, 174, 175, 176, 177, 180, 181, 182, 183, 184, 185, 186,
        189, 190, 191, 192, 193, 194, 195, 196]:
            return "qimiflei"
    else:
        return None








